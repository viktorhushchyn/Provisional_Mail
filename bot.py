import logging
import random
import string
import requests
import asyncio
import os
from datetime import datetime, timedelta

from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.types import BufferedInputFile
from dotenv import load_dotenv

# ================== –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è .env ==================
print("DEBUG: loading .env...")
load_dotenv()  # –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î .env
API_TOKEN = os.getenv("BOT_TOKEN")
print("DEBUG: BOT_TOKEN =", API_TOKEN)  # –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞

if not API_TOKEN:
    raise ValueError("‚ö†Ô∏è BOT_TOKEN –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ –≤ .env!")

# ================== –õ–æ–≥—É–≤–∞–Ω–Ω—è ==================
logging.basicConfig(level=logging.INFO)

bot = Bot(token=API_TOKEN)
dp = Dispatcher()

# ================== –ü–∞–º‚Äô—è—Ç—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤ ==================
user_accounts = {}
last_mail_ids = {}
stored_messages = {}
stored_attachments = {}
new_users = set()

BASE_URL = "https://api.mail.tm"

# ================== –î–æ–ø–æ–º—ñ–∂–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó ==================
def gen_password(length=12):
    chars = string.ascii_letters + string.digits
    return "".join(random.choice(chars) for _ in range(length))

def create_account(retries=3):
    for attempt in range(retries):
        try:
            domains = requests.get(f"{BASE_URL}/domains").json()["hydra:member"]
            domain = random.choice(domains)["domain"]

            username = "".join(random.choices(string.ascii_lowercase + string.digits, k=10))
            email = f"{username}@{domain}"
            password = gen_password()

            acc = requests.post(f"{BASE_URL}/accounts", json={
                "address": email,
                "password": password
            })

            if acc.status_code not in (200, 201):
                raise Exception(f"{acc.status_code}: {acc.text}")

            token_resp = requests.post(f"{BASE_URL}/token", json={
                "address": email,
                "password": password
            }).json()

            return {"address": email, "password": password, "token": token_resp["token"]}
        except Exception as e:
            logging.warning(f"‚ùå –ü–æ–º–∏–ª–∫–∞ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –∞–∫–∞—É–Ω—Ç–∞ (—Å–ø—Ä–æ–±–∞ {attempt+1}/{retries}): {e}")
            if attempt == retries - 1:
                raise Exception(f"–ù–µ –≤–¥–∞–ª–æ—Å—è —Å—Ç–≤–æ—Ä–∏—Ç–∏ –∞–∫–∞—É–Ω—Ç –ø—ñ—Å–ª—è {retries} —Å–ø—Ä–æ–±: {e}")
            asyncio.sleep(1)  # –ø–∞—É–∑–∞ –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–æ–º

def get_messages(token):
    headers = {"Authorization": f"Bearer {token}"}
    resp = requests.get(f"{BASE_URL}/messages", headers=headers).json()
    return resp.get("hydra:member", [])

def get_message(token, msg_id):
    headers = {"Authorization": f"Bearer {token}"}
    return requests.get(f"{BASE_URL}/messages/{msg_id}", headers=headers).json()

def to_kyiv_time_forced(iso_str: str) -> str:
    if not iso_str:
        return ""
    try:
        dt_utc = datetime.fromisoformat(iso_str.replace("Z", "+00:00"))
        dt_fixed = dt_utc + timedelta(hours=3)
        return dt_fixed.strftime("%d.%m.%Y %H:%M:%S")
    except Exception:
        return iso_str

# ================== –•–µ–Ω–¥–ª–µ—Ä–∏ ==================
@dp.message(Command("start"))
async def start_cmd(message: types.Message):
    kb = [
        [types.KeyboardButton(text="üìß –ó–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ –Ω–æ–≤—É –ø–æ—à—Ç—É")],
        [types.KeyboardButton(text="üì¨ –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Å–∫—Ä–∏–Ω—å–∫—É")]
    ]
    keyboard = types.ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True)

    await message.answer(
        "üëã –í—ñ—Ç–∞—é!\n\n"
        "‚ú® **ProvisionalMail** ‚Äì –±–æ—Ç –¥–ª—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è **—Ç–∏–º—á–∞—Å–æ–≤–∏—Ö –ø–æ—à—Ç–æ–≤–∏—Ö —Å–∫—Ä–∏–Ω—å–æ–∫**.\n\n"
        "üì© –¢–∏–º—á–∞—Å–æ–≤—ñ –ø–æ—à—Ç–∏ –ø–æ—Ç—Ä—ñ–±–Ω—ñ –¥–ª—è:\n"
        "‚Äî –†–µ—î—Å—Ç—Ä–∞—Ü—ñ—ó –Ω–∞ —Å–∞–π—Ç–∞—Ö –±–µ–∑ —Ä–∏–∑–∏–∫—É —Å–ø–∞–º—É üõ°Ô∏è\n"
        "‚Äî –¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è —Å–µ—Ä–≤—ñ—Å—ñ–≤ ‚öôÔ∏è\n"
        "‚Äî –ó–∞—Ö–∏—Å—Ç—É –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç—ñ üîí\n\n"
        "‚ö° –ù–∞—Ç–∏—Å–∫–∞–π –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂—á–µ, —â–æ–± –ø–æ—á–∞—Ç–∏:",
        reply_markup=keyboard,
        parse_mode="Markdown"
    )

    if message.from_user.id not in new_users:
        new_users.add(message.from_user.id)
        changelog = (
            "üì¢ **–©–æ –Ω–æ–≤–æ–≥–æ –≤ ProvisionalMail v1.2**\n"
            "‚Äî üïí –í–∏–ø—Ä–∞–≤–ª–µ–Ω–æ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è —á–∞—Å—É\n"
            "‚Äî üìé –ü—ñ–¥—Ç—Ä–∏–º–∫–∞ –≤–∫–ª–∞–¥–µ–Ω—å\n"
            "‚Äî üîò –ö–Ω–æ–ø–∫–∞ ¬´–ü–æ–∫–∞–∑–∞—Ç–∏ –≤–∫–ª–∞–¥–µ–Ω–Ω—è¬ª\n"
            "‚Äî üìÑ –ö–Ω–æ–ø–∫–∞ ¬´–ü–æ–∫–∞–∑–∞—Ç–∏ –ø–æ–≤–Ω–∏–π –ª–∏—Å—Ç¬ª\n"
            "‚Äî üé® –û–Ω–æ–≤–ª–µ–Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å\n"
            "‚Äî üõ° –û–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ø–æ—à—Ç–∏\n"
            "‚Äî üóíÔ∏è –ü—Ä–∏–º—ñ—Ç–∫–∞: –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –ª–∏—Å—Ç–∞ –±–æ—Ç–æ–º ‚âà 1-2 —Ö–≤–∏–ª–∏–Ω–∏!"
        )
        await message.answer(changelog, parse_mode="Markdown")

@dp.message(F.text == "üìß –ó–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ –Ω–æ–≤—É –ø–æ—à—Ç—É")
async def get_mail(message: types.Message):
    try:
        account = create_account()
        user_accounts[message.from_user.id] = account
        last_mail_ids[message.from_user.id] = set()
        await message.answer(
            f"üìß –¢–≤–æ—è —Ç–∏–º—á–∞—Å–æ–≤–∞ –ø–æ—à—Ç–∞: `{account['address']}`",
            parse_mode="Markdown"
        )
    except Exception as e:
        logging.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –∞–∫–∞—É–Ω—Ç–∞: {e}")
        await message.answer(f"‚ö†Ô∏è –ù–µ –≤–¥–∞–ª–æ—Å—è —Å—Ç–≤–æ—Ä–∏—Ç–∏ –∞–∫–∞—É–Ω—Ç: {e}")

@dp.message(F.text == "üì¨ –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —Å–∫—Ä–∏–Ω—å–∫—É")
async def inbox(message: types.Message):
    if message.from_user.id not in user_accounts:
        await message.answer("‚ö†Ô∏è –°–ø–æ—á–∞—Ç–∫—É —Å—Ç–≤–æ—Ä–∏ –ø–æ—à—Ç—É –Ω–∞—Ç–∏—Å–Ω—É–≤—à–∏ 'üìß –ó–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ –Ω–æ–≤—É –ø–æ—à—Ç—É'")
        return

    account = user_accounts[message.from_user.id]
    try:
        messages = get_messages(account["token"])
    except Exception as e:
        logging.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –ª–∏—Å—Ç—ñ–≤: {e}")
        await message.answer(f"‚ö†Ô∏è –ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ –ª–∏—Å—Ç–∏: {e}")
        return

    if not messages:
        await message.answer("üì≠ –ü–æ–∫–∏ —â–æ –ª–∏—Å—Ç—ñ–≤ –Ω–µ–º–∞—î.")
    else:
        text = "üì® –í—Ö—ñ–¥–Ω—ñ –ª–∏—Å—Ç–∏:\n\n"
        for mail in messages:
            mail_id = mail["id"]
            subject = mail.get("subject", "(–±–µ–∑ —Ç–µ–º–∏)")
            from_who = mail.get("from", {}).get("address", "–Ω–µ–≤—ñ–¥–æ–º–æ")
            date_str = to_kyiv_time_forced(mail.get("createdAt", ""))
            has_att = "—Ç–∞–∫" if mail.get("hasAttachments") else "–Ω—ñ"

            text += (
                f"ID: {mail_id}\n"
                f"–í—ñ–¥: {from_who}\n"
                f"–¢–µ–º–∞: {subject}\n"
                f"‚è∞ {date_str}\n"
                f"üìé –í–∫–ª–∞–¥–µ–Ω–Ω—è: {has_att}\n\n"
            )
        await message.answer(text)

# ================== –§–æ–Ω–æ–≤–∏–π —Ç–∞—Å–∫ ==================
async def check_new_mails():
    while True:
        for user_id, account in list(user_accounts.items()):
            try:
                messages = get_messages(account["token"])
                for mail in messages:
                    mail_id = mail["id"]
                    if mail_id not in last_mail_ids.get(user_id, set()):
                        last_mail_ids.setdefault(user_id, set()).add(mail_id)
                        full_mail = get_message(account["token"], mail_id)

                        subject = full_mail.get("subject", "–ë–µ–∑ —Ç–µ–º–∏")
                        from_who = full_mail.get("from", {}).get("address", "–Ω–µ–≤—ñ–¥–æ–º–æ")
                        body = full_mail.get("text") or "üìé (—É –ª–∏—Å—Ç—ñ –ª–∏—à–µ –≤–∫–ª–∞–¥–µ–Ω–Ω—è)"
                        date_str = to_kyiv_time_forced(full_mail.get("createdAt", ""))
                        attachments = full_mail.get("attachments", []) or []
                        stored_attachments[(user_id, mail_id)] = attachments

                        kb = InlineKeyboardBuilder()
                        have_buttons = False

                        if attachments:
                            kb.button(
                                text=f"üìé –ü–æ–∫–∞–∑–∞—Ç–∏ –≤–∫–ª–∞–¥–µ–Ω–Ω—è ({len(attachments)})",
                                callback_data=f"show_attachments:{mail_id}"
                            )
                            have_buttons = True

                        if len(body) > 1500:
                            stored_messages[(user_id, mail_id)] = body
                            kb.button(
                                text="üìÑ –ü–æ–∫–∞–∑–∞—Ç–∏ –ø–æ–≤–Ω–∏–π –ª–∏—Å—Ç",
                                callback_data=f"show_full:{mail_id}"
                            )
                            have_buttons = True
                            await bot.send_message(
                                user_id,
                                "üì¨ –ù–æ–≤–∏–π –ª–∏—Å—Ç!\n"
                                f"‚è∞ –ß–∞—Å –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –ª–∏—Å—Ç–∞ ‚Äì {date_str}\n\n"
                                f"–í—ñ–¥: {from_who}\n"
                                f"–¢–µ–º–∞: {subject}\n\n"
                                "‚ÑπÔ∏è –£ –ª–∏—Å—Ç—ñ –∑–∞–±–∞–≥–∞—Ç–æ —Å–∏–º–≤–æ–ª—ñ–≤.",
                                reply_markup=kb.as_markup() if have_buttons else None
                            )
                        else:
                            await bot.send_message(
                                user_id,
                                "üì¨ –ù–æ–≤–∏–π –ª–∏—Å—Ç!\n"
                                f"‚è∞ –ß–∞—Å –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –ª–∏—Å—Ç–∞ ‚Äì {date_str}\n\n"
                                f"–í—ñ–¥: {from_who}\n"
                                f"–¢–µ–º–∞: {subject}\n\n"
                                f"{body}",
                                reply_markup=kb.as_markup() if have_buttons else None
                            )

            except Exception as e:
                logging.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ —É check_new_mails: {e}")

        await asyncio.sleep(30)

# ================== Callback —Ö–µ–Ω–¥–ª–µ—Ä–∏ ==================
@dp.callback_query(F.data.startswith("show_full:"))
async def show_full(callback: types.CallbackQuery):
    mail_id = callback.data.split(":")[1]
    key = (callback.from_user.id, mail_id)
    if key in stored_messages:
        body = stored_messages[key]
        await callback.message.answer(f"üìÑ –ü–æ–≤–Ω–∏–π —Ç–µ–∫—Å—Ç –ª–∏—Å—Ç–∞:\n\n{body}")
    else:
        await callback.message.answer("‚ö†Ô∏è –õ–∏—Å—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π.")
    await callback.answer()

@dp.callback_query(F.data.startswith("show_attachments:"))
async def show_attachments(callback: types.CallbackQuery):
    mail_id = callback.data.split(":")[1]
    key = (callback.from_user.id, mail_id)
    account = user_accounts.get(callback.from_user.id)

    if not account or key not in stored_attachments:
        await callback.message.answer("‚ö†Ô∏è –í–∫–ª–∞–¥–µ–Ω–Ω—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ñ.")
        await callback.answer()
        return

    attachments = stored_attachments[key]

    for att in attachments:
        try:
            url = f"{BASE_URL}/messages/{mail_id}/attachments/{att['id']}"
            headers = {"Authorization": f"Bearer {account['token']}"}
            file_resp = requests.get(url, headers=headers)

            filename = att.get("filename") or "attachment"
            content_type = (att.get("mimeType") or att.get("contentType") or "").lower()
            data = file_resp.content
            input_file = BufferedInputFile(data, filename=filename)

            if content_type.startswith("image/"):
                await bot.send_photo(callback.from_user.id, input_file, caption="üñº –í–∫–ª–∞–¥–µ–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è")
            elif content_type.startswith("video/"):
                await bot.send_video(callback.from_user.id, input_file, caption="üé• –í–∫–ª–∞–¥–µ–Ω–µ –≤—ñ–¥–µ–æ")
            else:
                await bot.send_document(callback.from_user.id, input_file)

        except Exception as e:
            logging.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –≤–∫–ª–∞–¥–µ–Ω–Ω—è: {e}")
            await callback.message.answer(f"‚ö†Ô∏è –ù–µ –≤–¥–∞–ª–æ—Å—è –Ω–∞–¥—ñ—Å–ª–∞—Ç–∏ –æ–¥–∏–Ω —ñ–∑ —Ñ–∞–π–ª—ñ–≤: {e}")

    await callback.answer()

# ================== Main ==================
async def main():
    asyncio.create_task(check_new_mails())
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
